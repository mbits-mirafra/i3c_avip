//----------------------------------------------------------------------
//   THIS IS AUTOMATICALLY GENERATED CODE
//   Generated by Mentor Graphics' Register Assistant UVM V4.4 (Build 1)
//   UVM Register Kit version 1.1
//----------------------------------------------------------------------
// Project         : registers
// Unit            : wb2spi_reg_pkg
// File            : wb2spi_reg_pkg.sv
//----------------------------------------------------------------------
// Created by      : mhorn
// Creation Date   : 4/20/15 4:05 PM
//----------------------------------------------------------------------
// Title           : registers
//
// Description     : 
//
//----------------------------------------------------------------------

//----------------------------------------------------------------------
// wb2spi_reg_pkg
//----------------------------------------------------------------------
package wb2spi_reg_pkg;

   import uvm_pkg::*;

   `include "uvm_macros.svh"

   /* DEFINE REGISTER CLASSES */



   //--------------------------------------------------------------------
   // Class: serial_peripheral_data_reg
   // 
   //--------------------------------------------------------------------

   class serial_peripheral_data_reg extends uvm_reg;
      `uvm_object_utils(serial_peripheral_data_reg)

      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "serial_peripheral_data_reg");
         super.new(name, 8, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         data = uvm_reg_field::type_id::create("data");

         data.configure(this, 8, 0, "RW", 0, 8'h00, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: serial_peripheral_status_reg
   // 
   //--------------------------------------------------------------------

   class serial_peripheral_status_reg extends uvm_reg;
      `uvm_object_utils(serial_peripheral_status_reg)

      uvm_reg_field serial_peripheral_interrupt_flag; 
      uvm_reg_field write_collision; 
      uvm_reg_field reserverd; 
      uvm_reg_field write_fifo_full; 
      uvm_reg_field write_fifo_empty; 
      uvm_reg_field read_fifo_full; 
      uvm_reg_field read_fifo_empty; 


      // Function: new
      // 
      function new(string name = "serial_peripheral_status_reg");
         super.new(name, 8, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         serial_peripheral_interrupt_flag = uvm_reg_field::type_id::create("serial_peripheral_interrupt_flag");
         write_collision = uvm_reg_field::type_id::create("write_collision");
         reserverd = uvm_reg_field::type_id::create("reserverd");
         write_fifo_full = uvm_reg_field::type_id::create("write_fifo_full");
         write_fifo_empty = uvm_reg_field::type_id::create("write_fifo_empty");
         read_fifo_full = uvm_reg_field::type_id::create("read_fifo_full");
         read_fifo_empty = uvm_reg_field::type_id::create("read_fifo_empty");

         serial_peripheral_interrupt_flag.configure(this, 1, 7, "W1C", 0, 1'b0, 1, 0, 0);
         write_collision.configure(this, 1, 6, "W1C", 0, 1'b0, 1, 0, 0);
         reserverd.configure(this, 2, 4, "RO", 0, 2'b00, 1, 0, 0);
         write_fifo_full.configure(this, 1, 3, "RO", 0, 1'b0, 1, 0, 0);
         write_fifo_empty.configure(this, 1, 2, "RO", 0, 1'b0, 1, 0, 0);
         read_fifo_full.configure(this, 1, 1, "RO", 0, 1'b0, 1, 0, 0);
         read_fifo_empty.configure(this, 1, 0, "RO", 0, 1'b0, 1, 0, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: serial_peripheral_control_reg
   // 
   //--------------------------------------------------------------------

   class serial_peripheral_control_reg extends uvm_reg;
      `uvm_object_utils(serial_peripheral_control_reg)

      rand uvm_reg_field serial_peripheral_interrupt_enable; 
      rand uvm_reg_field serial_peripheral_enable; 
      rand uvm_reg_field reserved; 
      rand uvm_reg_field master_mode_select; 
      rand uvm_reg_field clock_polarity; 
      rand uvm_reg_field clock_phase; 
      rand uvm_reg_field spi_clock_rate_select; 


      // Function: new
      // 
      function new(string name = "serial_peripheral_control_reg");
         super.new(name, 8, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         serial_peripheral_interrupt_enable = uvm_reg_field::type_id::create("serial_peripheral_interrupt_enable");
         serial_peripheral_enable = uvm_reg_field::type_id::create("serial_peripheral_enable");
         reserved = uvm_reg_field::type_id::create("reserved");
         master_mode_select = uvm_reg_field::type_id::create("master_mode_select");
         clock_polarity = uvm_reg_field::type_id::create("clock_polarity");
         clock_phase = uvm_reg_field::type_id::create("clock_phase");
         spi_clock_rate_select = uvm_reg_field::type_id::create("spi_clock_rate_select");

         serial_peripheral_interrupt_enable.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         serial_peripheral_enable.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         reserved.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         master_mode_select.configure(this, 1, 4, "RW", 0, 1'b0, 1, 1, 0);
         clock_polarity.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         clock_phase.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         spi_clock_rate_select.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: serial_peripheral_extensions_reg
   // 
   //--------------------------------------------------------------------

   class serial_peripheral_extensions_reg extends uvm_reg;
      `uvm_object_utils(serial_peripheral_extensions_reg)

      rand uvm_reg_field interrupt_count; 
      rand uvm_reg_field reserved; 
      rand uvm_reg_field extended_spi_clock_rate_sel; 


      // Function: new
      // 
      function new(string name = "serial_peripheral_extensions_reg");
         super.new(name, 8, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         interrupt_count = uvm_reg_field::type_id::create("interrupt_count");
         reserved = uvm_reg_field::type_id::create("reserved");
         extended_spi_clock_rate_sel = uvm_reg_field::type_id::create("extended_spi_clock_rate_sel");

         interrupt_count.configure(this, 2, 6, "RW", 0, 2'b00, 1, 1, 0);
         reserved.configure(this, 4, 2, "RW", 0, 4'h0, 1, 1, 0);
         extended_spi_clock_rate_sel.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass




   /* BLOCKS */



   //--------------------------------------------------------------------
   // Class: wb2spi_reg_block_bus_map_coverage
   // 
   // Coverage for the 'bus_map' in 'wb2spi_reg_model'
   //--------------------------------------------------------------------

   class wb2spi_reg_block_bus_map_coverage extends uvm_object;
      `uvm_object_utils(wb2spi_reg_block_bus_map_coverage)

      covergroup ra_cov(string name) with function sample(uvm_reg_addr_t addr, bit is_read);

         option.per_instance = 1;
         option.name = name; 

         ADDR: coverpoint addr {
            bins spcr = {'h0};
            bins spsr = {'h1};
            bins spdr = {'h2};
            bins sper = {'h3};
         }

         RW: coverpoint is_read {
            bins RD = {1};
            bins WR = {0};
         }

         ACCESS: cross ADDR, RW;

      endgroup: ra_cov

      function new(string name = "wb2spi_reg_block_bus_map_coverage");
         ra_cov = new(name);
      endfunction: new

      function void sample(uvm_reg_addr_t offset, bit is_read);
         ra_cov.sample(offset, is_read);
      endfunction: sample

   endclass: wb2spi_reg_block_bus_map_coverage



   //--------------------------------------------------------------------
   // Class: wb2spi_reg_model
   // 
   // Register block
   //--------------------------------------------------------------------

   class wb2spi_reg_model extends uvm_reg_block;
      `uvm_object_utils(wb2spi_reg_model)

      rand serial_peripheral_control_reg spcr; 
      rand serial_peripheral_status_reg spsr; 
      rand serial_peripheral_data_reg spdr; 
      rand serial_peripheral_extensions_reg sper; 

      uvm_reg_map bus_map; 
      wb2spi_reg_block_bus_map_coverage bus_map_cg;


      // Function: new
      // 
      function new(string name = "wb2spi_reg_model");
         super.new(name, build_coverage(UVM_CVR_ALL));
      endfunction


      // Function: build
      // 
      virtual function void build();

         add_hdl_path("hdl_top.DUT");

         if(has_coverage(UVM_CVR_ADDR_MAP)) begin
            bus_map_cg = wb2spi_reg_block_bus_map_coverage::type_id::create("bus_map_cg");
            bus_map_cg.ra_cov.set_inst_name(this.get_full_name());
            void'(set_coverage(UVM_CVR_ADDR_MAP));
         end
         spcr = serial_peripheral_control_reg::type_id::create("spcr");
         spcr.configure(this, null, "spcr");
         spcr.build();

         spsr = serial_peripheral_status_reg::type_id::create("spsr");
         spsr.configure(this, null, "spsr");
         spsr.build();

         spdr = serial_peripheral_data_reg::type_id::create("spdr");
         spdr.configure(this);
         spdr.build();

         sper = serial_peripheral_extensions_reg::type_id::create("sper");
         sper.configure(this, null, "sper");
         sper.build();

         bus_map = create_map("bus_map", 'h0, 1, UVM_LITTLE_ENDIAN);
         default_map = bus_map;

         bus_map.add_reg(spcr, 'h0, "RW");
         bus_map.add_reg(spsr, 'h1, "RW");
         bus_map.add_reg(spdr, 'h2, "RW");
         bus_map.add_reg(sper, 'h3, "RW");

         lock_model();
      endfunction


      // Function: sample
      // 
      function void sample(uvm_reg_addr_t offset, bit is_read, uvm_reg_map  map);
         if(get_coverage(UVM_CVR_ADDR_MAP)) begin
            if(map.get_name() == "bus_map") begin
               bus_map_cg.sample(offset, is_read);
            end
         end
      endfunction: sample

   endclass


endpackage

//----------------------------------------------------------------------
//   THIS IS AUTOMATICALLY GENERATED CODE
//   Generated by Mentor Graphics' Register Assistant UVM V2020.1 (Build 1)
//   UVM Register Kit version 1.1
//----------------------------------------------------------------------
// Project         : 2020.1
// Unit            : alu_reg_pkg
// File            : alu_reg_pkg.sv
//----------------------------------------------------------------------
// Created by      : aedemo
// Creation Date   : 1/11/21 4:53 PM
//----------------------------------------------------------------------
// Title           : 2020.1
//
// Description     : 
//
//----------------------------------------------------------------------

//----------------------------------------------------------------------
// alu_reg_pkg
//----------------------------------------------------------------------
package alu_reg_pkg;

   import uvm_pkg::*;

   `include "uvm_macros.svh"

   /* DEFINE REGISTER CLASSES */



   //--------------------------------------------------------------------
   // Class: a_reg
   // 
   // Operand A Register
   //--------------------------------------------------------------------

   class a_reg extends uvm_reg;
      `uvm_object_utils(a_reg)

      uvm_reg_field rsvrd; // Reserved
      rand uvm_reg_field a; // Operand A


      // Function: coverage
      // 
      covergroup cg_vals;
         a	 : coverpoint a.value[7:0];
      endgroup


      // Constraints 
      constraint op_a_c {a.value[7:0] < 5;}


      // Function: new
      // 
      function new(string name = "a_reg");
         super.new(name, 32, build_coverage(UVM_CVR_FIELD_VALS));
         add_coverage(build_coverage(UVM_CVR_FIELD_VALS));
         if(has_coverage(UVM_CVR_FIELD_VALS))
            cg_vals = new();
      endfunction


      // Function: sample_values
      // 
      virtual function void sample_values();
         super.sample_values();
         if (get_coverage(UVM_CVR_FIELD_VALS))
            cg_vals.sample();
      endfunction


      // Function: build
      // 
      virtual function void build();
         rsvrd = uvm_reg_field::type_id::create("rsvrd");
         a = uvm_reg_field::type_id::create("a");

         rsvrd.configure(this, 24, 8, "RO", 0, 24'h000000, 1, 0, 1);
         a.configure(this, 8, 0, "RW", 0, 8'h00, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: b_reg
   // 
   // Operand B Register
   //--------------------------------------------------------------------

   class b_reg extends uvm_reg;
      `uvm_object_utils(b_reg)

      uvm_reg_field rsvrd; // Reserved
      rand uvm_reg_field b; // Operand B


      // Function: coverage
      // 
      covergroup cg_vals;
         b	 : coverpoint b.value[7:0];
      endgroup


      // Constraints 
      constraint op_b_c {b.value[7:0] < 15;}


      // Function: new
      // 
      function new(string name = "b_reg");
         super.new(name, 32, build_coverage(UVM_CVR_FIELD_VALS));
         add_coverage(build_coverage(UVM_CVR_FIELD_VALS));
         if(has_coverage(UVM_CVR_FIELD_VALS))
            cg_vals = new();
      endfunction


      // Function: sample_values
      // 
      virtual function void sample_values();
         super.sample_values();
         if (get_coverage(UVM_CVR_FIELD_VALS))
            cg_vals.sample();
      endfunction


      // Function: build
      // 
      virtual function void build();
         rsvrd = uvm_reg_field::type_id::create("rsvrd");
         b = uvm_reg_field::type_id::create("b");

         rsvrd.configure(this, 24, 8, "RO", 0, 24'h000000, 1, 0, 1);
         b.configure(this, 8, 0, "RW", 0, 8'h00, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: ctrl_reg
   // 
   // Control Register
   //--------------------------------------------------------------------

   class ctrl_reg extends uvm_reg;
      `uvm_object_utils(ctrl_reg)

      uvm_reg_field rsvrd; // Reserved
      rand uvm_reg_field strt; // Perform Operation


      // Function: coverage
      // 
      covergroup cg_vals;
         strt	 : coverpoint strt.value[0];
      endgroup



      // Function: new
      // 
      function new(string name = "ctrl_reg");
         super.new(name, 32, build_coverage(UVM_CVR_FIELD_VALS));
         add_coverage(build_coverage(UVM_CVR_FIELD_VALS));
         if(has_coverage(UVM_CVR_FIELD_VALS))
            cg_vals = new();
      endfunction


      // Function: sample_values
      // 
      virtual function void sample_values();
         super.sample_values();
         if (get_coverage(UVM_CVR_FIELD_VALS))
            cg_vals.sample();
      endfunction


      // Function: build
      // 
      virtual function void build();
         rsvrd = uvm_reg_field::type_id::create("rsvrd");
         strt = uvm_reg_field::type_id::create("strt");

         rsvrd.configure(this, 31, 1, "RO", 0, 31'b0000000000000000000000000000000, 1, 0, 0);
         strt.configure(this, 1, 0, "WO", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: op_reg
   // 
   // Operation Register
   //--------------------------------------------------------------------

   class op_reg extends uvm_reg;
      `uvm_object_utils(op_reg)

      uvm_reg_field rsvrd; // Reserved
      rand uvm_reg_field op; // Operation


      // Function: coverage
      // 
      covergroup cg_vals;
         op	 : coverpoint op.value[2:0];
      endgroup



      // Function: new
      // 
      function new(string name = "op_reg");
         super.new(name, 32, build_coverage(UVM_CVR_FIELD_VALS));
         add_coverage(build_coverage(UVM_CVR_FIELD_VALS));
         if(has_coverage(UVM_CVR_FIELD_VALS))
            cg_vals = new();
      endfunction


      // Function: sample_values
      // 
      virtual function void sample_values();
         super.sample_values();
         if (get_coverage(UVM_CVR_FIELD_VALS))
            cg_vals.sample();
      endfunction


      // Function: build
      // 
      virtual function void build();
         rsvrd = uvm_reg_field::type_id::create("rsvrd");
         op = uvm_reg_field::type_id::create("op");

         rsvrd.configure(this, 29, 3, "RO", 0, 29'b00000000000000000000000000000, 1, 0, 0);
         op.configure(this, 3, 0, "RW", 0, 3'b000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: result_reg
   // 
   // Result Register
   //--------------------------------------------------------------------

   class result_reg extends uvm_reg;
      `uvm_object_utils(result_reg)

      uvm_reg_field rsvrd; // Reserved
      rand uvm_reg_field rslt; // Result


      // Function: coverage
      // 
      covergroup cg_vals;
         rslt	 : coverpoint rslt.value[15:0];
      endgroup



      // Function: new
      // 
      function new(string name = "result_reg");
         super.new(name, 32, build_coverage(UVM_CVR_FIELD_VALS));
         add_coverage(build_coverage(UVM_CVR_FIELD_VALS));
         if(has_coverage(UVM_CVR_FIELD_VALS))
            cg_vals = new();
      endfunction


      // Function: sample_values
      // 
      virtual function void sample_values();
         super.sample_values();
         if (get_coverage(UVM_CVR_FIELD_VALS))
            cg_vals.sample();
      endfunction


      // Function: build
      // 
      virtual function void build();
         rsvrd = uvm_reg_field::type_id::create("rsvrd");
         rslt = uvm_reg_field::type_id::create("rslt");

         rsvrd.configure(this, 16, 16, "RO", 0, 16'h0000, 1, 0, 1);
         rslt.configure(this, 16, 0, "RW", 0, 16'h0000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: scratch_mem
   // 
   // Memory
   //--------------------------------------------------------------------

   class scratch_mem extends uvm_mem;
      `uvm_object_utils(scratch_mem)



      // Function: new
      // 
      function new(string name = "scratch_mem");
         super.new(name, 'hfec, 32, "RW", UVM_NO_COVERAGE);
      endfunction
   endclass




   /* BLOCKS */



   //--------------------------------------------------------------------
   // Class: alu_block_apb_map_coverage
   // 
   // Coverage for the 'apb_map' in 'alu_block'
   //--------------------------------------------------------------------

   class alu_block_apb_map_coverage extends uvm_object;
      `uvm_object_utils(alu_block_apb_map_coverage)

      covergroup ra_cov(string name) with function sample(uvm_reg_addr_t addr, bit is_read);

         option.per_instance = 1;
         option.name = name; 

         ADDR: coverpoint addr {
            bins a_reg_reg = {'h0};
            bins b_reg_reg = {'h4};
            bins op_reg_reg = {'h8};
            bins result_reg_reg = {'hc};
            bins ctrl_reg_reg = {'h10};
         }

         RW: coverpoint is_read {
            bins RD = {1};
            bins WR = {0};
         }

         ACCESS: cross ADDR, RW;

      endgroup: ra_cov

      function new(string name = "alu_block_apb_map_coverage");
         ra_cov = new(name);
      endfunction: new

      function void sample(uvm_reg_addr_t offset, bit is_read);
         ra_cov.sample(offset, is_read);
      endfunction: sample

   endclass: alu_block_apb_map_coverage



   //--------------------------------------------------------------------
   // Class: alu_block
   // 
   // ALU
   //--------------------------------------------------------------------

   class alu_block extends uvm_reg_block;
      `uvm_object_utils(alu_block)

      rand a_reg a_reg_reg; // Operand A
      rand b_reg b_reg_reg; // Operand B
      rand op_reg op_reg_reg; // Operation
      rand result_reg result_reg_reg; // Result
      rand ctrl_reg ctrl_reg_reg; // Control
      scratch_mem scratch_mem_mem; // MEM instances

      uvm_reg_map apb_map; // SW sub block map
      alu_block_apb_map_coverage apb_map_cg;


      // Function: new
      // 
      function new(string name = "alu_block");
         super.new(name, build_coverage(UVM_CVR_ALL));
      endfunction


      // Function: build
      // 
      virtual function void build();

         if(has_coverage(UVM_CVR_ADDR_MAP)) begin
            apb_map_cg = alu_block_apb_map_coverage::type_id::create("apb_map_cg");
            apb_map_cg.ra_cov.set_inst_name(this.get_full_name());
            void'(set_coverage(UVM_CVR_ADDR_MAP));
         end
         a_reg_reg = a_reg::type_id::create("a_reg_reg");
         a_reg_reg.configure(this);
         a_reg_reg.build();

         b_reg_reg = b_reg::type_id::create("b_reg_reg");
         b_reg_reg.configure(this);
         b_reg_reg.build();

         op_reg_reg = op_reg::type_id::create("op_reg_reg");
         op_reg_reg.configure(this);
         op_reg_reg.build();

         result_reg_reg = result_reg::type_id::create("result_reg_reg");
         result_reg_reg.configure(this);
         result_reg_reg.build();

         ctrl_reg_reg = ctrl_reg::type_id::create("ctrl_reg_reg");
         ctrl_reg_reg.configure(this);
         ctrl_reg_reg.build();

         scratch_mem_mem = scratch_mem::type_id::create("scratch_mem_mem");
         scratch_mem_mem.configure(this);

         apb_map = create_map("apb_map", 'h0, 4, UVM_LITTLE_ENDIAN, 1);
         default_map = apb_map;

         apb_map.add_reg(a_reg_reg, 'h0, "RW");
         apb_map.add_reg(b_reg_reg, 'h4, "RW");
         apb_map.add_reg(op_reg_reg, 'h8, "RW");
         apb_map.add_reg(result_reg_reg, 'hc, "RW");
         apb_map.add_reg(ctrl_reg_reg, 'h10, "RW");
         apb_map.add_mem(scratch_mem_mem, 'h14, "RW");

         uvm_resource_db #(bit)::set({"REG::", this.result_reg_reg.get_full_name()}, "NO_REG_BIT_BASH_TEST", 1);
         lock_model();
      endfunction


      // Function: sample
      // 
      function void sample(uvm_reg_addr_t offset, bit is_read, uvm_reg_map  map);
         if(get_coverage(UVM_CVR_ADDR_MAP)) begin
            if(map.get_name() == "apb_map") begin
               apb_map_cg.sample(offset, is_read);
            end
         end
      endfunction: sample

   endclass



   //--------------------------------------------------------------------
   // Class: alu_reg_model_apb_map_coverage
   // 
   // Coverage for the 'apb_map' in 'alu_reg_model'
   //--------------------------------------------------------------------

   class alu_reg_model_apb_map_coverage extends uvm_object;
      `uvm_object_utils(alu_reg_model_apb_map_coverage)

      covergroup ra_cov(string name) with function sample(uvm_reg_addr_t addr, bit is_read);

         option.per_instance = 1;
         option.name = name; 

         ADDR: coverpoint addr {
         }

         RW: coverpoint is_read {
            bins RD = {1};
            bins WR = {0};
         }

         ACCESS: cross ADDR, RW;

      endgroup: ra_cov

      function new(string name = "alu_reg_model_apb_map_coverage");
         ra_cov = new(name);
      endfunction: new

      function void sample(uvm_reg_addr_t offset, bit is_read);
         ra_cov.sample(offset, is_read);
      endfunction: sample

   endclass: alu_reg_model_apb_map_coverage



   //--------------------------------------------------------------------
   // Class: alu_reg_model
   // 
   // Top block for the ALU design
   //--------------------------------------------------------------------

   class alu_reg_model extends uvm_reg_block;
      `uvm_object_utils(alu_reg_model)

      rand alu_block alu; 

      uvm_reg_map apb_map; // ALU APB top block map
      alu_reg_model_apb_map_coverage apb_map_cg;


      // Function: new
      // 
      function new(string name = "alu_reg_model");
         super.new(name, build_coverage(UVM_CVR_ALL));
      endfunction


      // Function: build
      // 
      virtual function void build();

         add_hdl_path("top.dut");

         if(has_coverage(UVM_CVR_ADDR_MAP)) begin
            apb_map_cg = alu_reg_model_apb_map_coverage::type_id::create("apb_map_cg");
            apb_map_cg.ra_cov.set_inst_name(this.get_full_name());
            void'(set_coverage(UVM_CVR_ADDR_MAP));
         end
         alu = alu_block::type_id::create("alu");
         alu.configure(this);
         alu.build();

         apb_map = create_map("apb_map", 'h0, 4, UVM_LITTLE_ENDIAN, 1);
         default_map = apb_map;

         apb_map.add_submap(alu.apb_map, 'h0);

         lock_model();
      endfunction


      // Function: sample
      // 
      function void sample(uvm_reg_addr_t offset, bit is_read, uvm_reg_map  map);
         if(get_coverage(UVM_CVR_ADDR_MAP)) begin
            if(map.get_name() == "apb_map") begin
               apb_map_cg.sample(offset, is_read);
            end
         end
      endfunction: sample

   endclass


endpackage

<!DOCTYPE html>  
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <title>DPI_Link_Users_Guide</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style id="mkstylesheet">
body{-webkit-font-smoothing:antialiased;font-family:"Helvetica Neue",Helvetica,Arial,Verdana,sans-serif;margin:30px 0 0;padding:0;background:#fff}#wrapper{padding:20px}li{font-size:110%}li li{font-size:100%}li p{font-size:100%;margin:.5em 0}h1{color:#000}h2{color:#111}h3{color:#111;margin:0}h4{color:#111}h5{color:#111}h6{font-size:1em;line-height:1.5em;margin:1.5em 0}body,p,td,div{color:#111;font-family:"Helvetica Neue",Helvetica,Arial,Verdana,sans-serif;word-wrap:break-word}a{color:#0d6ea1;text-decoration:none;-webkit-transition:color 0.2s ease-in-out;-moz-transition:color 0.2s ease-in-out;-o-transition:color 0.2s ease-in-out;-ms-transition:color 0.2s ease-in-out;transition:color 0.2s ease-in-out}a:hover{color:#3593d9}body{font-size:15px;line-height:21px;margin:0 auto}h1{font-size:37px;line-height:42px;margin-top:42px;margin-bottom:21px}h2{font-size:27px;line-height:42px;margin-top:42px;margin-bottom:21px}h3{font-size:20px;line-height:21px;margin-top:21px;margin-bottom:21px}h4{font-size:20px;line-height:21px;margin-top:21px;margin-bottom:21px}p,ul,ol,pre,table,blockquote{margin-top:21px;margin-bottom:21px}hr{border:1px solid;margin:-1px 0}ul ul,ol ol,ul ol,ol ul{margin-top:0;margin-bottom:0}b,strong,em,small,code{line-height:1}.footnote{color:#0d6ea1;font-size:.8em;vertical-align:super}abbr,acronym{border-bottom:1px dotted #aaa}#wrapper img{max-width:100%;height:auto}dd{font-size:1em;margin-bottom:1em}li>p:first-child{margin:0}ul,ol{padding-left:1.5em}ul ul,ul ol{margin-bottom:.4em}caption,col,colgroup,table,tbody,td,tfoot,th,thead,tr{border-spacing:0}table{border:1px solid rgba(0,0,0,0.25);border-collapse:collapse;display:table;empty-cells:hide;margin:-1px 0 1.3125em;padding:0;table-layout:fixed}caption{display:table-caption;font-weight:700}col{display:table-column}colgroup{display:table-column-group}tbody{display:table-row-group}tfoot{display:table-footer-group}thead{display:table-header-group}td,th{display:table-cell}tr{display:table-row}table th,table td{font-size:1.1em;line-height:1.3;padding:.5em 1em 0}table thead{background:rgba(0,0,0,0.15);border:1px solid rgba(0,0,0,0.15);border-bottom:1px solid rgba(0,0,0,0.2)}table tbody{background:rgba(0,0,0,0.05)}table tfoot{background:rgba(0,0,0,0.15);border:1px solid rgba(0,0,0,0.15);border-top:1px solid rgba(0,0,0,0.2)}figure{display:inline-block;overflow:hidden;position:relative;margin:1em 0 2em}figcaption{font-style:italic;text-align:center;background:white;color:#666}.poetry pre{display:block;font-family:Georgia,Garamond,serif !important;font-size:110% !important;font-style:italic;line-height:1.6em;margin-left:1em}.poetry pre code{font-family:Georgia,Garamond,serif !important;word-break:break-all;word-break:break-word;-webkit-hyphens:auto;-moz-hyphens:auto;hyphens:auto;white-space:pre-wrap}blockquote p{font-size:110%;font-style:italic;line-height:1.6em}sup,sub,a.footnote{font-size:1.4ex;height:0;line-height:1;position:relative;vertical-align:super}sub{vertical-align:sub;top:-1px}p,h5{font-size:1.1429em;line-height:1.3125em;margin:1.3125em 0}dt,th{font-weight:700}table tr:nth-child(odd),table th:nth-child(odd),table td:nth-child(odd){background:rgba(255,255,255,0.06)}table tr:nth-child(even),table td:nth-child(even){background:rgba(200,200,200,0.25)}@media print{img,table,figure{page-break-inside:avoid}#wrapper{background:#fff;color:#303030;padding:10px;position:relative;text-indent:0}}@media screen{.inverted{background:#252a2a}.inverted #wrapper{background:#252a2a;color:#eee}.inverted hr{border-color:#333f40 !important}.inverted p,.inverted td,.inverted li,.inverted h1,.inverted h2,.inverted h3,.inverted h4,.inverted h5,.inverted h6,.inverted th,.inverted .math,.inverted caption,.inverted dt,.inverted dd{color:#eee}.inverted pre{background:#ccc;color:#111}.inverted table{background:none}.inverted table tr:nth-child(odd),.inverted table td:nth-child(odd){background:none}.inverted a{color:#acd1d5}::selection{background:rgba(157,193,200,0.5)}h1::selection{background-color:rgba(45,156,208,0.3)}h2::selection{background-color:rgba(90,182,224,0.3)}h3::selection,h4::selection,h5::selection,h6::selection,li::selection,ol::selection{background-color:rgba(133,201,232,0.3)}code::selection{background-color:rgba(0,0,0,0.7);color:#eee}code span::selection{background-color:rgba(0,0,0,0.7) !important;color:#eee !important}a::selection{background-color:rgba(255,230,102,0.2)}.inverted a::selection{background-color:rgba(255,230,102,0.6)}td::selection,th::selection,caption::selection{background-color:rgba(180,237,95,0.5)}}
#mkreplaced-toc{list-style-position:inside;padding:0;margin:0 0 0 1rem;list-style-type:none}#mkreplaced-toc li::before{content:''}#mkreplaced-toc li{font-size:1.5rem;line-height:1.5;font-weight:normal}#mkreplaced-toc li ul{font-size:1.3rem;font-weight:300;padding:.5rem 0;margin:0 0 0 1rem}#mkreplaced-toc li.missing{list-style-type:none !important}#mkreplaced-toc.max-1 ul,#mkreplaced-toc.max1 ul{display:none}#mkreplaced-toc.max-2 ul ul,#mkreplaced-toc.max2 ul ul{display:none}#mkreplaced-toc.max-3 ul ul ul,#mkreplaced-toc.max3 ul ul ul{display:none}#mkreplaced-toc.max-4 ul ul ul ul,#mkreplaced-toc.max4 ul ul ul ul{display:none}#mkreplaced-toc.max-5 ul ul ul ul ul,#mkreplaced-toc.max5 ul ul ul ul ul{display:none}
#wrapper #generated-toc-clone, #wrapper #mkreplaced-toc, #wrapper #generated-toc-clone ul, #wrapper #mkreplaced-toc ul {
    list-style-position: inside;
}
#wrapper #generated-toc-clone li.missing, #wrapper #mkreplaced-toc li.missing {
    list-style-type: none!important;
}
#wrapper #generated-toc-clone, #wrapper #mkreplaced-toc {
    list-style-type: upper-roman;
}
#wrapper #generated-toc-clone>li>ul, #wrapper #mkreplaced-toc>li>ul  {
    list-style-type: decimal;
}
#wrapper #generated-toc-clone>li>ul>li>ul, #wrapper #mkreplaced-toc>li>ul>li>ul {
    list-style-type: decimal-leading-zero;
}
#wrapper #generated-toc-clone>li>ul>li>ul>li>ul, #wrapper #mkreplaced-toc>li>ul>li>ul>li>ul {
    list-style-type: lower-greek;
}
#wrapper #generated-toc-clone>li>ul>li>ul>li>ul>li>ul, #wrapper #mkreplaced-toc>li>ul>li>ul>li>ul>li>ul {
    list-style-type: disc;
}
#wrapper #generated-toc-clone>li>ul>li>ul>li>ul>li>ul>li>ul, #wrapper #mkreplaced-toc>li>ul>li>ul>li>ul>li>ul>li>ul {
    list-style-type: square;
}
#wrapper #generated-toc-clone,#wrapper #mkreplaced-toc{list-style-position:outside!important;margin-left:2rem;}
</style>

<style id="mkprintstyles">@media print{#wrapper #generated-toc-clone,#generated-toc{display:none!important;}
html,body,#wrapper{font-size:10pt!important;}
}
</style>


</head>
<body class="normal">
  <div id="wrapper">
      <h1 id="overview">Overview</h1>

<p>Testbench Acceleration (TBX) communicates between the HVL and XRTL testbenches using DPI-C function calls. While it&#8217;s possible to share a SystemVerilog interface between XRTL and HVL using the <code>uvm_config_db</code> database, this approach merely hides the DPI-C function calls going on beneath the surface. </p>

<p>The Mentor Consulting Division (MCD) has chosen to implement communication between HVL and XRTL by explicitly calling DPI-C function calls rather than using the &#8220;virtual interface&#8221; approach. </p>

<p>This document shows how we&#8217;ve implemented this solution. You can <a href="#creatinganewpair">jump to the steps involved in making an agent</a> if you just want a refresher on those steps. </p>

<h1 id="structurediagram">The Structure of HVL/XRTL Communication</h1>

<p>The most common communication between HVL and XRTL occurs when HVL agents talk to an XRTL driver or monitor. A typical system might look like this:</p>

<pre><code>UVM                                     XRTL  
uvm_test_top                               xrtl_top  
    env  
        printer_1_h  
        agent_1_h                              bfm_1  
           driver_h  |-- driver_proxy - C --&gt;   driver  
           monitor_h &lt;-- monitor_proxy - C --|  monitor  
        printer_2_h  
        agent_2_h                              bfm_2  
           driver_h  |-- driver_proxy - C --&gt;   driver  
           monitor_h &lt;-- monitor_proxy - C --|  monitor 
</code></pre>

<p>This picture shows the overview of the architecture in which multiple agents are talking to multiple BFMs. (These can be multiple instances of the same BFM or different BFM types). On the HVL side you have two instances of an agent class that instantiates a driver object and a monitor object. Each of these objects instantiates a proxy linked to an XRTL module.</p>

<h2 id="dpifunctioncalls">DPI Function Calls</h2>

<p>This system implements all communication between the HVL and XRTL using function calls. Function always run in zero time. If we implement something that takes time, such as a bus access, the driver calls a function to launch the activity and the BFM calls a function to notify the driver of completion. </p>

<p>The DPI-C mechanism only allows communication between SystemVerilog compilation units. Compilation units consist of the following:</p>

<ul>
<li>Packages</li>
<li>Modules</li>
<li>Interfaces</li>
<li>Programs</li>
</ul>

<p>For our purposes we only use SystemVerilog packages on the HVL side and SystemVerilog modules on the XRTL side. (We sometimes use SystemVerilog interfaces on the XRTL side to encapsulate signals between modules, but the primary communication happens between a package and a module.)</p>

<p>The SystemVerilog XRTL hierarchical paths are the key to communication. The HVL uses the hierarchical path to access the correct scope in the XRTL and the XRTL modules use their own hierarchical path to access the correct packages and analysis ports on the HVL side.</p>

<h2 id="rulesforxrtlpaths">Rules for XRTL Paths</h2>

<p>We store XRTL paths in strings using the following rules:</p>

<ul>
<li><p>All XRTL paths must be complete and start at root.</p></li>
<li><p>All XRTL paths are stored using the SystemVerilog &#8220;dot&#8221; method. So one of the drivers above would have the path <code>&quot;xrtl_top.bfm_1.driver&quot;</code>. If the user provides <code>&quot;/xrtl_top/foo_bfm/driver&quot;</code> the system converts it to the &#8220;dot&#8221; method internally. <a href="#fn:1" id="fnref:1" title="see footnote" class="footnote">[1]</a></p></li>
<li><p>XRTL paths should be defined as SystemVerilog macros to avoid typos.</p></li>
</ul>

<h1 id="dpi_link_pkgbaseclasses"><code>dpi_link_pkg</code> Base Classes</h1>

<p>The MCD communication system relies upon a set of base classes in the <code>dpi_link_pkg</code> to make it easier to implement a DPI-C communication mechanism. This document assumes the functionality of the <code>dpi_link_pkg</code> base classes and does not explain how they are implemented. That is discussed in a different document.</p>

<h2 id="dpi_link_macros.svhmacros"><code>dpi_link_macros.svh</code> Macros</h2>

<p>The <code>dpi_link</code> directory provides a macro file to be included in all compilation units. Here are the macros:</p>

<h3 id="declare_set_gettypename"><code>declare_set_get (type, name)</code></h3>

<p>Allowing an object&#8217;s user to directly access a class&#8217;s data members is a dangerous coding style. It can lead to bugs and make it difficult to extend the class&#8217;s functionality. It can also lead to a common type of bug where a user reads data from a data member before the data member has been written. </p>

<p>The <code>declare_set_get()</code> macro declares a variable and creates a mechanism for catching read-before-write errors. It takes two arguments: the type of the variable and the variable name. Here is an example.</p>

<p>The macro call</p>

<p><code>declare_set_get(int, counter)</code></p>

<p>creates the following:</p>

<pre><code>protected int counter;  
protected bit counter_set = 0;

function void set_counter(int n);  
    this.counter = n;  
    counter_set = 1'b1;  
endfunction

function int get_counter();  
    if (!counter_set)  
        `uvm_fatal(&quot;get_counter&quot;, Tried to get...&quot;)  
    return counter;  
endfunction
</code></pre>

<p>If you use this macro, you should always use the set/get methods even within the class to take advantage of the error checking capabilities. </p>

<h3 id="declare_rand_set_gettypename"><code>declare_rand_set_get(type, name)</code></h3>

<p>This is the same as <code>declare-set_get</code> but it creates a randomizable variable. </p>

<h3 id="mcd_uvm_new_component"><code>mcd_uvm_new_component</code></h3>

<p>Creates the standard UVM component constructor.</p>

<h3 id="mcd_uvm_new_object"><code>mcd_uvm_new_object</code></h3>

<p>Creates the standard UVM object constructor.</p>

<h3 id="dpi_link_proxy_gettype"><code>dpi_link_proxy_get(type)</code></h3>

<p>The <code>dpi_link_proxy</code> base class is supposed to be a singleton in which the constructor <code>new()</code> is protected and cannot be called. Instead the user is supposed to use the static function <code>get(string path)</code>. </p>

<p>This macro creates the static <code>get()</code> function. The <code>get()</code> function also stores the proxy in a pool where it can be accessed later using the path. </p>

<h2 id="dpi_link_baseclasses"><code>dpi_link_*</code> Base Classes</h2>

<p>These base classes provide an easy-to-leverage framework for creating DPI HVL/XRTL communication. They ensure that your HVL hierarchy matches the XRTL hierarchy.</p>

<table>
<colgroup>
<col style="text-align:left;"/>
<col style="text-align:left;"/>
</colgroup>

<thead>
<tr>
	<th style="text-align:left;">Base Class</th>
	<th style="text-align:left;">Description</th>
</tr>
</thead>

<tbody>
<tr>
	<td style="text-align:left;" colspan="2"><code>dpi_link_component extends uvm_component</code></td>
</tr>
<tr>
	<td style="text-align:left;"></td>
	<td style="text-align:left;">This class has an additional argument in its constructor. The argument must contain the path to the associated XRTL module. The class checks for the existence of the module instance when you instantiate it.</td>
</tr>
<tr>
	<td style="text-align:left;" colspan="2"><code>dpi_link_agent extends uvm_agent</code></td>
</tr>
<tr>
	<td style="text-align:left;"></td>
	<td style="text-align:left;">Agents that extend <code>dpi_link_agent</code> require the user to provide an <code>xrtl_path</code> string parameter when they declare a handle for this agent. The agent checks that the <code>xrtl_path</code> string actually points to a location in the hierarchy.</td>
</tr>
<tr>
	<td style="text-align:left;" colspan="2"><code>dpi_link_driver #(REQ,RSP) extends uvm_driver #(REQ,RSP)</code></td>
</tr>
<tr>
	<td style="text-align:left;"></td>
	<td style="text-align:left;" colspan="2">The <code>dpi_link_driver</code> extends <code>uvm_driver</code> and provides a constructor that takes an agent_path as an argument.</td>
</tr>
<tr>
	<td style="text-align:left;" colspan="2"><code>dpi_link_proxy extends uvm_object</code></td>
</tr>
<tr>
	<td style="text-align:left;"></td>
	<td style="text-align:left;">A proxy serves as a communications channel between the HVL and XRTL. A driver proxy contains methods that call functions in the driver BFM, and a monitor proxy contains an analysis port that accepts data from the monitor. This class extends <code>uvm_object</code> and it uses the XRTL path to it&#8217;s attendant driver or monitor as its name.</td>
</tr>
</tbody>
</table>

<p>Using these base classes ensures that we have a common communication mechanism in all our code and that our code will catch simple errors immediately.</p>

<h1 id="acommunicationsexample">A Communications Example</h1>

<p>We are going to learn about the &#8220;DPI-C&#8221; communications mechanism by walking through an example that runs a simple agent called <code>foo_agent</code>. <code>foo_agent</code> contains a driver and a monitor. </p>

<p>When you call the <code>start_numbers(int n);</code> function in the XRTL, the <code>foo_driver_bfm</code> starts sending <code>n</code> numbers to the <code>foo_monitor_bfm</code>. The monitor sends the numbers back to the test bench where they go through an analysis port in the <code>foo_agent</code> and land in a <code>foo_printer</code>. There are two instances of <code>foo</code> and when you run them they look like this:</p>

<pre><code># UVM_INFO @ 0: reporter [RNTST] Running test foo_test...  
# UVM_INFO foo_printer.svh(7) @ 70: uvm_test_top.foo_env_h.foo_printer_2_h [TINY PRINTER] foo_item.n =n: 0000000a  
# UVM_INFO foo_printer.svh(7) @ 70: uvm_test_top.foo_env_h.foo_printer_1_h [TINY PRINTER] foo_item.n =n: 0000000a  
# UVM_INFO foo_printer.svh(7) @ 90: uvm_test_top.foo_env_h.foo_printer_2_h [TINY PRINTER] foo_item.n =n: 00000009  
# UVM_INFO foo_printer.svh(7) @ 90: uvm_test_top.foo_env_h.foo_printer_1_h [TINY PRINTER] foo_item.n =n: 00000009  
# UVM_INFO foo_printer.svh(7) @ 110: uvm_test_top.foo_env_h.foo_printer_2_h [TINY PRINTER] foo_item.n =n: 00000008  
...
</code></pre>

<p>Here is a diagram of the testbench that created this output:</p>

<h2 id="thefooexamplediagram">The Foo Example Diagram</h2>

<p>So to copy the diagram from above, we are implementing this:</p>

<pre><code>UVM                                            XRTL  
uvm_test_top                                     xrtl_top  
    foo_env  
        foo_printer_1_h  
        foo_agent_1_h #(xrtl_top.foo_bfm_1)             foo_bfm_1()  
           driver_h     |-- foo_driver_proxy - C ---&gt;    driver()  
           monitor_h    &lt;-- foo_monitor_proxy - C --|    monitor() 

        foo_printer_2_h  
        foo_agent_2_h #(xrtl_top.foo_bfm_2)             foo_bfm_2()  
           driver_h     |-- foo_driver_proxy - C ---&gt;    driver()  
           monitor_h    &lt;-- foo_monitor_proxy - C --|    monitor() 
</code></pre>

<p>Let&#8217;s walk through the code of the example starting with the XRTL.</p>

<h2 id="fooxrtl">Foo XRTL</h2>

<p>There are only four kinds of modules in the XRTL:</p>

<h3 id="xrtl_top"><code>xrtl_top.sv</code></h3>

<pre><code>module xrtl_top;  
    foo_bfm foo_bfm_1();  
    foo_bfm foo_bfm_2();  
endmodule
</code></pre>

<p>The XRTL top simply instantiates two of the foo_bfm modules.</p>

<h3 id="foo_bfm"><code>foo_bfm.sv</code></h3>

<p>The <code>foo_bfm</code> module does a bit more. It instantiates a driver and a monitor and provides them with a clock. The driver and monitor must have the instance name <code>driver</code> and <code>monitor</code> for the system to work.</p>

<pre><code>module foo_bfm;  
    `include &quot;dpi_link_imports.svh&quot;

    byte data;  
    bit clk;  
    bit rst_n;

    foo_driver_bfm driver(.clk, .rst_n, .data);  
    foo_monitor_bfm monitor(.clk, .rst_n, .data);

    always #10 clk = ~clk;  
    initial begin  
        rst_n = 0;  
        clk = 0;  
        @(posedge clk);  
        @(posedge clk);  
        rst_n = 1;  
        trigger_hvl_event(0); // Tell HVL Out of Reset  
    end  
endmodule
</code></pre>

<p>Notice the call to <code>trigger_hvl_event(0)</code> at the end of the <code>initial</code> block. The <code>dpi_link_imports.svh</code> header file declares this function. It tells the HVL that we are out of reset and that stimulus can begin.<a href="#fn:2" id="fnref:2" title="see footnote" class="footnote">[2]</a></p>

<h3 id="foo_driver_bfm"><code>foo_driver_bfm.sv</code></h3>

<p>The <code>foo_driver_bfm</code> generates stimulus and sends it to the monitor. It demonstrates several aspects of HVL/XRTL communication. First we&#8217;ll look the code:</p>

<pre><code>module foo_driver_bfm(input bit clk, input bit rst_n, output byte data);  
export &quot;DPI-C&quot; function start_numbers;  
`include &quot;dpi_link_imports.svh&quot;

    byte set_data;  
    event command_here;

    always @(posedge clk)  
        if (!rst_n)  
            data &lt;= 0;  
        else begin  
            if (data != 0) begin  
                data &lt;= data - 1;  
                if (data - 1 == 0)  
                    trigger_hvl_event(data);  
            end  
        end

    function void start_numbers(input int unsigned n);  
        set_data = n;  
        -&gt; command_here;  
    endfunction

    always begin  
        @(command_here);  
        @(posedge clk);  
        data &lt;= set_data;  
    end

endmodule
</code></pre>

<p>The basic functionality is simple. The driver checks to see that data is not zero. If data is not zero then it decrements data until data reaches zero. Here is how it communicates with the HVL:</p>

<ul>
<li><code>export &quot;DPI-C&quot; function start_numbers;</code>&#8212;This line tells the simulator that this module is providing a <code>start_numbers()</code> function to the C code.</li>
<li><code>include &quot;dpi_link_imports.svh&quot;</code>&#8212;This declares the <code>trigger_hvl_event()</code> function.</li>
<li><code>trigger_hvl_event(data)</code>&#8212;This line sends an event to the HVL. We happen to know that the HVL interprets this event as notifiction that the <code>start_numbers</code> command is complete. We don&#8217;t know whether the HVL has blocked waiting for this information, but it doesn&#8217;t matter to us, we simply provide the event.</li>
<li><code>function void start_numbers(input int unsigned n);</code>&#8212;This function stores the number <code>n</code> in <code>set_data</code> then triggers and event to tell the system that we have a new command.</li>
<li><code>always begin @(command_here)</code>&#8212;This is the correct way to put data into an XRTL model. We wait for the function call to trigger the <code>command_here</code> event, then we sync up with the positive edge of the clock and load the data into the <code>data</code> register. It is not wise to have clocked data changing randomly in the middle of a clock cycle.</li>
</ul>

<p>This is a simple example in which the XRTL notifies the HVL when it is finished. We could create other function calls that return more data than the single int that can be sent with <code>trigger_hvl_data</code>. We could also receive much more data in the function call that sets off the operation.</p>

<h3 id="monitor_bfm"><code>foo_monitor_bfm.sv</code></h3>

<p>This monitor sends non-zero data back to the HVL on each clock edge:</p>

<pre><code>module foo_monitor_bfm(input bit clk, input bit rst_n, input byte data);  
    import &quot;DPI-C&quot; context function void send_number(int unsigned n);

    always @(posedge clk)  
        if (data != 0)  
            send_number(data);

endmodule
</code></pre>

<p>This is a simple monitor. The module imports a <code>send_number()</code> function from the C side of the testbench with this line:</p>

<pre><code>import &quot;DPI-C&quot; context function void send_number(int unsigned n);
</code></pre>

<p>This line links the <code>send_number()</code> function with a C function call of the same name. The <code>context</code> keyword says that the scope of this instance of the monitor should be provided along with the function call. We&#8217;ll see later that we can access this scope with the <code>svGetScope()</code> function and use it to get a handle to the correct analysis port.</p>

<h3 id="xrtlsummary">XRTL Summary</h3>

<p>The example provides a summary of the things we need to do to create XRTL that can communicate with HVL through the &#8220;DPI-C&#8221; mechanism.</p>

<ul>
<li>The DPI <code>import</code> and <code>export</code> lines go after the <code>module</code> line at the top of the module.</li>
<li>If you define the function inside the module you <code>export</code> it.</li>
<li>If you expect the function to be defined in the C library you <code>import</code> it.</li>
<li>You will usually want to provide the <code>context</code> keyword on imports so that your scope information travels with your function call.</li>
<li>If an exported function call provides data to the module, that data must be synchronized with the clock using the event/@(posedge clk) method described above.</li>
<li>The module and driver must be instantiated in the BFM with the names <code>driver</code> and <code>module</code>.</li>
</ul>

<h2 id="hvluvmstructure">HVL UVM Structure</h2>

<p>As we saw in the <a href="#structurediagram">structure diagram</a> at the top of this document, the MCD DPI system mirrors the XRTL side of the testbench with agents on the HVL side. These are stored in the UVM hierarchy.</p>

<p>In this section we&#8217;ll build out the UVM structure. </p>

<h3 id="hvl_top"><code>hvl_top.sv</code></h3>

<p>The dual top testbench must have two tops. Here is the HVL top: </p>

<pre><code>module hvl_top;  
    import uvm_pkg::*;  
    `include &quot;uvm_macros.svh&quot;  
    import foo_xrtl_pkg::*;  
    import foo_pkg::*;

    initial  
        run_test(&quot;foo_test&quot;);  
endmodule
</code></pre>

<p>The <code>hvl_top</code> imports a <code>foo_xrtl_pkg</code> and a <code>foo_pkg</code>. The <code>foo_xrtl_pkg</code> (and all XRTL packages) contain definitions that the XRTL needs and that can be compiled in <code>tbxcompile</code>. In this example the XRTL package is empty. </p>

<p>This is a simple example with one test, so we specify the test in the <code>run_test</code> task. Normally we call this task with no argument.</p>

<h3 id="foo_test"><code>foo_test.svh</code></h3>

<p>The test does nothing but instantiate the environment: </p>

<pre><code>class foo_test extends uvm_test;  
    `uvm_component_utils(foo_test)

    foo_env foo_env_h;

    function new(string name = &quot;&quot;, uvm_component parent);  
        super.new(name,parent);  
    endfunction


    function void build_phase(uvm_phase phase);  
        foo_env_h = new(&quot;foo_env_h&quot;, this);  
    endfunction

endclass
</code></pre>

<p>Nothing to see here, move along.</p>

<h3 id="foo_env"><code>foo_env.svh</code></h3>

<p>The <code>foo_env</code> demonstrates how easy it is to use a properly constructed <code>dpi_link_agent</code>. All you have to do is provide the XRTL path in the constructor call:</p>

<pre><code>class foo_env extends uvm_env;  
    `uvm_component_utils(foo_env)  
    `mcd_uvm_new_component

    foo_agent foo_agent_1_h;  
    foo_agent foo_agent_2_h;  
    foo_printer foo_printer_1_h;  
    foo_printer foo_printer_2_h;

    function void build_phase(uvm_phase phase);  
        foo_agent_1_h = new(&quot;foo_agent_1_h&quot;, this, &quot;xrtl_top.foo_bfm_1&quot;);  
        foo_agent_2_h = new(&quot;foo_agent_2_h&quot;, this, &quot;xrtl_top.foo_bfm_2&quot;);  
        foo_printer_1_h = new(&quot;foo_printer_1_h&quot;,this);  
        foo_printer_2_h = new(&quot;foo_printer_2_h&quot;,this);  
    endfunction

    function void connect_phase(uvm_phase phase);  
        foo_agent_1_h.ap.connect(foo_printer_1_h.analysis_export);  
        foo_agent_2_h.ap.connect(foo_printer_2_h.analysis_export);  
    endfunction

endclass
</code></pre>

<p>The <code>foo_agent</code> instantiations in the <code>build_phase()</code> function provide the path to the two BFM&#8217;s in the design. This system assumes that these BFMs contain instances named <code>driver</code> and <code>monitor</code>. </p>

<p>In this case the <code>foo_agent</code> provides an analysis port associated with the monitor BFMs referenced in the agent. When the <a href="#monitor_bfm"><code>monitor_bfm</code></a> calls the <code>send_number()</code> function, the data comes out of the correct analysis port.</p>

<p>If you are not an agent developer, this is all you need to do to connect HVL agents to XRTL BFMs. </p>

<h2 id="insidetheagent">Inside the Agent</h2>

<p>The <code>foo_agent</code> class creates the sequence that drives data through the simulation and provides an analysis port associated with the monitor BFM. Here is the code with comments interspersed:</p>

<pre><code>class foo_agent extends dpi_link_agent;  
    `uvm_component_utils(foo_agent)
</code></pre>

<p>Notice that we extend <code>dpi_link_agent.</code> This gives us a new constructor and the <code>get_xrtl_path()</code> method.</p>

<pre><code>    foo_driver  foo_driver_h;  
    foo_monitor foo_monitor_h;
</code></pre>

<p>Declare the driver and the monitor components. These handle the details of communication with their respective BFMs.</p>

<pre><code>    uvm_sequencer #(foo_item) foo_sequencer_h;  
    foo_seq seq;  
    dpi_link_proxy foo_xrtl_top_proxy;
</code></pre>

<p>The <code>dpi_link_proxy</code> class allows us to communicate with a specific XRTL module. We will use this object to synchronize with the XRTL reset cycle. </p>

<pre><code>    uvm_analysis_port #(foo_item) ap;
</code></pre>

<p>This is the analysis port that will receive data from the <code>foo_monitor_h</code> object and present it to the outside world.</p>

<pre><code>    function new(string name = &quot;&quot;, uvm_component parent=null, string agent_path = &quot;&quot;);  
        super.new(name,parent, agent_path);  
    endfunction
</code></pre>

<p>This is the constructor for an <code>dpi_link_agent</code>. It has an additional argument, <code>agent_path</code> that receives the path for this agents BFM. The parent class <code>dpi_link_agent</code> processes the <code>agent_path</code>.</p>

<pre><code>    function void build_phase(uvm_phase phase);  
        foo_driver_h = new(&quot;foo_driver_h&quot;,this, {get_xrtl_path(),&quot;.driver&quot;});  
        foo_monitor_h = new(&quot;foo_monitor_h&quot;,this, {get_xrtl_path(),&quot;.monitor&quot;);
</code></pre>

<p>The <code>foo_driver_h</code> and <code>foo_monitor_h</code> objects also take their XRTL path as a third argument. Use the <code>get_xrtl_path()</code> method to ensure that the path is formatted correctly. We append <code>&quot;.driver&quot;</code> and <code>&quot;.monitor&quot;</code> on the path that you pass to get the path to the XRTL driver BFM and monitor BFM.</p>

<pre><code>        foo_sequencer_h = new(&quot;foo_sequencer_h&quot;, this);  
        foo_xrtl_top_proxy = new(get_xrtl_path());
</code></pre>

<p>The <code>foo_xrtl_top_proxy</code> allows us to synchronize with the reset function. Pass it the XRTL path as well so that it connects properly. </p>

<pre><code>        ap = new(&quot;ap&quot;, this);  
    endfunction

    function void connect_phase(uvm_phase phase);  
        foo_driver_h.seq_item_port.connect(foo_sequencer_h.seq_item_export);  
        foo_monitor_h.ap.connect(ap);  
    endfunction
</code></pre>

<p>Connect the driver to the sequencer and the top level analysis port to the analysis port in the monitor. </p>

<pre><code>    task run_phase(uvm_phase phase);  
        int x;  
        phase.raise_objection(this);  
        foo_xrtl_top_proxy.wait_for(x);  
        seq = new(&quot;seq&quot;);  
        seq.start(foo_sequencer_h);  
        phase.drop_objection(this);  
    endtask  
endclass
</code></pre>

<p>The <code>run_phase</code> task uses the <code>foo_xrtl_top_proxy.wait_for()</code> task to wait for the XRTL to come out of reset. The <a href="#foo_bfm">foo_bfm.sv</a> code calls the <code>trigger_hvl_event</code> function to release the <code>wait_for()</code> task. The <code>x</code> variable is a dummy, we ignore it.</p>

<p>Once we are out of reset we run the sequence. </p>

<h3 id="foo_driver"><code>foo_driver.svh</code></h3>

<p>The <code>foo_driver</code> is just like an ordinary UVM driver except that it communicates with the BFM through a proxy object. The proxy provides methods that call functions in the BFM. Here is the <code>foo_driver</code>:</p>

<pre><code>class foo_driver extends dpi_link_driver #(foo_item, foo_item);  
    `uvm_component_utils(foo_driver)

    function new(string name = &quot;&quot;, uvm_component parent = null, string agent_path = &quot;&quot;);  
        super.new(name, parent, agent_path);  
    endfunction

    foo_driver_proxy foo_driver_proxy_h;

    function void build_phase(uvm_phase phase);  
        foo_driver_proxy_h = foo_driver_proxy::get(get_xrtl_path());  
    endfunction

    task run_phase(uvm_phase phase);  
        foo_item foo_item_h;  
        forever begin  
            int dummy;  
            seq_item_port.get_next_item(foo_item_h);  
            foo_driver_proxy_h.start_numbers(foo_item_h.get_n());  
            foo_driver_proxy_h.wait_for(dummy);  
            seq_item_port.item_done();  
        end  
    endtask  
endclass
</code></pre>

<p>The driver has the third argument on its constructor like the <code>foo_agent</code> does. All it does is pass the <code>agent_path</code> to the parent along with the other two constructor arguments.</p>

<p>This driver acts like most drivers except that we use the <code>foo_driver_proxy</code> to send commands to the DUT. We create a proxy by calling the <code>get()</code> static method in the <code>foo_driver_proxy</code> class. This gives us a handle to a singleton. Anyone in the testbench who gets a proxy using the same path string will receive the same proxy. Remember to use the <code>get_xrtl_path()</code> method to get the correct path. </p>

<p>Once we have a handle to a proxy, we use it in the <code>run_phase()</code> task. We get a <code>foo_item</code> out of the <code>seq_item_port</code> and pass the number <code>n</code> to the <code>start numbers</code> method. Then we wait for the <code>driver_bfm</code> to response by using the proxy&#8217;s <code>wait_for()</code> method.</p>

<p>The <code>start_numbers</code> method eventually calls the <code>start_numbers</code> function in the [<code>driver_bfm</code>][driver_bfm]. Then the <code>driver_bfm</code> calls <code>trigger_hvl_event</code> to tell us that it&#8217;s completed the job.</p>

<h3 id="foo_monitor"><code>foo_monitor.svh</code></h3>

<p>The <code>foo_monitor</code> class sets up the communication between the <code>monitor_bfm</code> and the analysis port <code>ap</code>. It does this using a <code>foo_monitor_proxy</code> object. The <code>foo_monitor_proxy</code> stores a handle to the analysis port and makes it available to the testbench. Here is the code:</p>

<pre><code>class foo_monitor extends dpi_link_monitor;  
    `uvm_component_utils(foo_monitor)
</code></pre>

<p>We extend <code>dpi_link_monitor</code> to handle the XRTL paths, etc.</p>

<pre><code>    uvm_analysis_port #(foo_item) ap;
</code></pre>

<p>Declare an analysis port. </p>

<pre><code>    `declare_set_get(foo_monitor_proxy, proxy)
</code></pre>

<p>Declare a variable to hold the proxy and it&#8217;s set/get methods. </p>

<pre><code>    function new (string name = &quot;&quot;, uvm_component parent = null, string xrtl_path = &quot;&quot;);  
        super.new(name, parent, xrtl_path);  
        foo_pkg::initialize_monitor(get_xrtl_path());  
    endfunction
</code></pre>

<p>Like the other XRTL classes, we have a constructor with an extra agent_path argument. We also call the <code>foo_pkg::initialize_monitor()</code> function to connect the XRTL monitor path to the package containing this class. In our case this is the <code>foo_pkg</code>. Once we make this call, the <code>monitor_bfm</code> will be able to send the data to the right package. </p>

<pre><code>    function void build_phase(uvm_phase phase);  
        foo_monitor_proxy proxy;  
        ap = new(&quot;ap&quot;, this);  
        proxy = foo_monitor_proxy::get(get_xrtl_path());  
        proxy.set_ap(ap);  
        set_proxy(proxy);  
    endfunction  
endclass
</code></pre>

<p>Create an analysis port and get a foo_monitor_proxy using the <code>get()</code> and <code>get_xrtl_path()</code> methods. Store the analysis port in the proxy. The proxy is automatically stored in a global pool, so now the rest of the testbench can access our analysis port.</p>

<p>Now when the <a href="#monitor_bfm">monitor_bfm</a> calls the <code>send_number</code> function, the data will appear in the analysis port stored in this proxy. We linked the proxy to the correct BFM when we passed <code>get_xrtl_path()</code> to the constructor. </p>

<h2 id="proxyconnections">Proxy Connections</h2>

<p>The <a href="#structurediagram">structure diagram</a> shows us that the HVL and XRTL communicate to each other through proxy classes and a C library.</p>

<p>We are defining two kinds of proxies: </p>

<ul>
<li>The driver proxy provides methods that coincide with the functions defined in the <code>driver_bfm</code> module.</li>
<li>The monitor proxy provides a <code>write()</code> method that writes data into its analysis port.</li>
</ul>

<p>In this section we will look at the proxy objects and their connection to the C layer. In the next section we will look at the C layer. </p>

<h3 id="foo_driver_proxy"><code>foo_driver_proxy.svh</code></h3>

<p>The <code>foo_driver_proxy</code> extends the <code>dpi_link_proxy</code> and provides the <code>start_numbers</code> method.</p>

<pre><code>class foo_driver_proxy extends dpi_link_proxy;  
`uvm_object_utils(foo_driver_proxy)

`mcd_uvm_new_object

function void start_numbers(int unsigned n);  
    hvl_start_numbers(get_xrtl_path(), n);  
endfunction

endclass : foo_driver_proxy
</code></pre>

<p>The <code>dpi_link_proxy</code> parent class handles the connection to the XRTL. The <code>foo_driver_proxy</code>&#8217;s <code>start_numbers</code> method takes a number from argument and uses it to call <code>hvl_start_numbers()</code>. The <code>hvl_start_numbers()</code> function takes the path to the XRTL module as its first argument and it uses that path to call the <code>start_numbers()</code> function in the <a href="#foo_driver_bfm"><code>foo_driver_bfm</code></a>. </p>

<h3 id="foo_monitor_proxy"><code>foo_monitor_proxy.svh</code></h3>

<p>The <code>foo_monitor_proxy</code> stores an analysis port and provides a <code>write()</code> method just like the one in the analysis port. </p>

<pre><code>class foo_monitor_proxy extends dpi_link_proxy;  
`uvm_object_utils(foo_monitor_proxy)

    protected function new(string name = &quot;&quot;);  
        super.new(name);  
    endfunction

    `dpi_link_proxy_get(foo_monitor_proxy)

    `declare_set_get(uvm_analysis_port #(foo_item), ap);

    function void write(foo_item t);  
        get_ap().write(t);  
    endfunction

endclass : foo_monitor_proxy
</code></pre>

<p>The monitor proxy demonstrates the proper way to extend the <code>dpi_link_proxy</code> class. Proxies allow you to access the functions in a BFM from anywhere in the testbench. Any code that has access to the XRTL path to a module instance can get a proxy to that and call the functions.</p>

<p>The proxy does this using the static <code>get()</code> method. All users who want to get a handle to a proxy do it like this:</p>

<pre><code>foo_monitor_proxy_h = foo_monitor_proxy::get(&lt;path string&gt;);
</code></pre>

<p>A user who calls the <code>new()</code> constructor is making a big mistake, so we keep that from happening by putting the <code>protected</code> keyword ahead of the typical <code>uvm_object</code> constructor.</p>

<p>The <code>dpi_link_proxy_get(foo_monitor_proxy)</code> macro creates the <code>get()</code> method and handles proxy storage.</p>

<p>To sum up, proxies need the following steps:</p>

<ol>
<li>Extend <code>dpi_link_proxy</code></li>
<li>Add the <code>protected</code> keyword to the constructor.</li>
<li>Instantiate the <code>dpi_link_proxy_get</code> macro to create the <code>get()</code> method.</li>
</ol>

<p>The rest of the proxy follows normally. In this case we instantiate an analysis port in our proxy using the following line:</p>

<pre><code>  `declare_set_get(uvm_analysis_port #(foo_item), ap);
</code></pre>

<p>This line declares the <code>ap</code> variable and creates two methods: <code>set_ap()</code> and <code>get_ap()</code>. These accessor functions protect the programmer from trying to access the analysis port before setting it.</p>

<p>Finally we provide a <code>write()</code> method that uses <code>get_ap()</code> to write data into the analsysis port.</p>

<p>The analysis port stored in the proxy is the same one that was stored in the <a href="#foo_monitor"><code>foo_monitor</code></a> during the <code>foo_monitor</code>&#8217;s build phase.</p>

<h3 id="send_number"><code>send_number</code> function</h3>

<p>When the [foo_monitor_bfm][foo_monitor_bfm] module calls <code>send_number</code> that function call goes through the C-layer and results in a call to <code>send_number</code> in the <code>foo_pkg</code>. The <code>send_number</code> function takes the path of the sending monitor instance and an integer as its arguments. Here is the annotated code from the <code>foo_pkg.sv</code> file.</p>

<pre><code>    function void send_number(string path, int unsigned n);  
        dpi_link_proxy_pool pool_h;  
        foo_monitor_proxy proxy_h;
</code></pre>

<p>The <a href="#foo_monitor_proxy"><code>foo_monitor_proxy</code></a> provides a <code>write()</code> method that sends the data to the correct analysis port.</p>

<p>The <code>dpi_link_proxy_pool</code> singleton contains a handle to all the proxies in the simulation indexed by their XRTL path. We check to see if our proxy exists before calling the <code>get()</code> function because the <code>get()</code> function creates a proxy if one doesn&#8217;t already exist and we don&#8217;t want to create a proxy at this step.</p>

<pre><code>        foo_item foo_item_h;  
        pool_h = dpi_link_proxy_pool::get_global_pool();  
        if (!pool_h.exists(path))  
            `uvm_fatal(&quot;XRTL SEND NUMBER&quot;, {&quot;Tried to send data to &quot;,path,&quot; without a proxy in the pool&quot;})  
        proxy_h = foo_monitor_proxy::get(path)
</code></pre>

<p>The C layer passed us a module path from the XRTL call. Get the global proxy pool and use that path to get the correct proxy. If there is no proxy in the pool then somebody forgot instantiate a <code>foo_monitor</code> object for this XRTL monitor. This is a fatal error. </p>

<p>Once we have the proxy, we create a new <code>foo_item</code>, store the number in it, and write the item into the analysis port using the proxy&#8217;s <code>write</code> method.</p>

<pre><code>        foo_item_h = new(&quot;foo_item_h&quot;);  
        foo_item_h.set_n(n);  
        proxy_h.write(foo_item_h);  
    endfunction
</code></pre>

<h1 id="thecconnection">The C Connection</h1>

<p>So far we&#8217;ve examined the XRTL side of the testbench and the &#8220;DPI-C&#8221; functions that those modules import and export, and we&#8217;ve examined the HVL side of the testbench and the &#8220;DPI-C&#8221; functions that the HVL packages import and export. </p>

<p>Now we&#8217;ll look at how the C layer connect them together.</p>

<p>Before we look at the details let&#8217;s see how the pieces of the communication fit together. </p>

<p>The first thing to note is that all DPI function calls in XRTL result in a function call in the HVL, and that all DPI function calls in the HVL result in a function call in the XRTL. By convention these functions have the same name.</p>

<p>We connect the two with function calls in the C code. By convention these function calls have the same name as the end point function calls but with the &#8220;C_&#8221; prefix before the name.</p>

<p>Let&#8217;s look at several communication scenarios. The tables below show communication for different operations. The calling order is from top to bottom.</p>

<table>
<colgroup>
<col style="text-align:center;"/>
<col style="text-align:left;"/>
<col style="text-align:left;"/>
</colgroup>

<thead>
<tr>
	<th style="text-align:center;" colspan="3">Driver starts numbers</th>
</tr>
<tr>
	<th style="text-align:center;">Source</th>
	<th style="text-align:left;">Function call</th>
	<th style="text-align:left;">Import or Export</th>
</tr>
</thead>

<tbody>
<tr>
	<td style="text-align:center;">HVL</td>
	<td style="text-align:left;"><code>foo_driver_proxy.start_numbers(int n)</code></td>
	<td style="text-align:left;"></td>
</tr>
<tr>
	<td style="text-align:center;">C</td>
	<td style="text-align:left;"><code>C_start_numbers(char * path, int n)</code></td>
	<td style="text-align:left;">imported to <code>foo_pkg</code></td>
</tr>
<tr>
	<td style="text-align:center;">XRTL</td>
	<td style="text-align:left;"><code>start_numbers(int n)</code></td>
	<td style="text-align:left;">exported from <code>foo_driver_bfm</code></td>
</tr>
</tbody>
</table>

<table>
<colgroup>
<col style="text-align:center;"/>
<col style="text-align:left;"/>
<col style="text-align:left;"/>
<col style="text-align:left;"/>
</colgroup>

<thead>
<tr>
	<th style="text-align:center;" colspan="3">Monitor sends a number</th>
</tr>
<tr>
	<th style="text-align:center;">Source</th>
	<th style="text-align:left;">Function call</th>
	<th style="text-align:left;">Import or Export</th>
</tr>
</thead>

<tbody>
<tr>
	<td style="text-align:center;">XRTL</td>
	<td style="text-align:left;"><code>monitor.send_number(int n)</code></td>
	<td style="text-align:left;"></td>
</tr>
<tr>
	<td style="text-align:center;">C</td>
	<td style="text-align:left;"><code>C_send_number(char * path, int n)</code></td>
	<td style="text-align:left;">imported to <code>foo_monitor_bfm</code></td>
</tr>
<tr>
	<td style="text-align:center;">HVL</td>
	<td style="text-align:left;">Get proxy using path and <code>proxy_h.write()</code></td>
	<td style="text-align:left;">exported from <code>foo_pkg</code></td>
</tr>
</tbody>
</table>

<p>This shows that function calls in both directions go through a C function and that that C function calls another function using the module path to control the call. We&#8217;ll now examine this code more closely.</p>

<h2 id="svscope...onefunctiontorulethemall"><code>svScope()</code>&#8230;One Function to Rule them All</h2>

<p>The &#8220;DPI-C&#8221; communication system relies primarily upon a SystemVerilog simulator concept called <em>scope</em>, or more precisely (as described in svdpi.h) <code>svScope</code>.</p>

<pre><code>typedef void* svScope;
</code></pre>

<p>As you can see <code>svScope</code> is a C pointer. It points to a specific instance of a SystemVerilog compilation unit. In the case of modules, it generally points to an instance of a module. <a href="#thefooexamplediagram">In our example</a> <code>xrtl_top.foo_bfm_1.driver</code> has a different svScope than <code>xrtl_top.foo_bfm_2.driver</code>. Similarly, <code>foo_pkg</code> has an svScope even though it is not instanced anywhere.</p>

<p>It is important not to confuse svScope with UVM hierarchy. While SystemVerilog knows about svScope (allowing you to reference signals with fully qualified paths such as <code>xrtl_top.foo_bfm_2.driver.data</code>) SystemVerilog does not know about the UVM hierarchy. The UVM hierarchy is simply a directed tree created from a linked list of objects. It is a user data structure, not a simulation construct. </p>

<p>It is possible for C code to call exported functions in specific instances of the SystemVerilog hierarchy. The module <code>foo_driver_bfm</code> exports a function called <code>start_numbers</code>. There are two instances of this module in the design, so the C code needs to know the correct scope when it calls <code>start_numbers</code>.</p>

<p>SystemVerilog provides functions that allow the C code to manipulate svScope. Here they are:</p>

<table>
<colgroup>
<col style="text-align:left;"/>
<col style="text-align:left;"/>
</colgroup>

<thead>
<tr>
	<th style="text-align:left;">Function Declaration</th>
	<th style="text-align:left;">Description</th>
</tr>
</thead>

<tbody>
<tr>
	<td style="text-align:left;"><code>typedef void* svScope;</code></td>
	<td style="text-align:left;">The pointer to a SystemVerilog scope</td>
</tr>
<tr>
	<td style="text-align:left;"><code>svScope svGetScope();</code></td>
	<td style="text-align:left;">When you import a function using the <code>context</code> keyword the scope of the calling module instance gets implicitly passed with the function call. You use <code>svGetScope()</code> to get the pointer to the current instance.</td>
</tr>
<tr>
	<td style="text-align:left;"><code>svScope svSetScope(const svScope scope);</code></td>
	<td style="text-align:left;">Changes the context of a C function to a new context, for example you might want to change context from the calling <code>xrtl_top.foo_bfm_1.monitor</code> scope to the <code>foo_pkg</code> scope.</td>
</tr>
<tr>
	<td style="text-align:left;"><code>const char* svGetNameFromScope(const svScope);</code></td>
	<td style="text-align:left;">Returns a C string that contains the path to the passed scope in the &#8220;.&#8221; format. For example <code>&quot;xrtl_top.foo_bfm_1.driver&quot;</code>.</td>
</tr>
<tr>
	<td style="text-align:left;"><code>svScope svGetScopeFromName(const char* scopeName);</code></td>
	<td style="text-align:left;">This function returns an <code>svScope</code> pointer given a path string. It returns <code>null</code> if there is no scope associated with the path.</td>
</tr>
</tbody>
</table>

<p>Using these functions, we can travel freely between the HVL and XRTL worlds.</p>

<h2 id="thepathstring">The Path String</h2>

<p>The path string points to a specific scope in the simulation. While it is impossible for the HVL to access the XRTL hierarchically, it is possible for the HVL to store the XRTL hierarchy as path strings. The HVL calls function in specific instances in the XRTL hierarchy by passing the path string as an argument to a C function, then the C function uses <code>svGetScopeFromName()</code> and <code>svSetScope()</code> to switch context to the correct function.</p>

<p>When going from XRTL to HVL, the <code>dpi_link</code> namespace provides functions that allow you to connect a path string to an HVL package. </p>

<h2 id="dpi_linkfunctionnamingconventions">dpi_link Function Naming Conventions</h2>

<p>By convention we match the names of the routines in the HVL and XRTL and put the &#8220;C_&#8221; prefix in front of the C function that links the two. So in the case of the example the driver proxy will have a method called <code>start_numbers()</code> and the XRTL also has a function called <code>start_numbers()</code>. These are linked by a C function called <code>C_start_numbers()</code>.</p>

<h2 id="thefoo_tc.cppsourcecode">The <code>foo_tc.cpp</code> Source Code</h2>

<p>The thin C layer between the HVL and XRTL is thin indeed. Here is the source code:</p>

<pre><code>#include &quot;dpiheader.h&quot;  
#include &quot;dpi_link.h&quot;  
#include &lt;string&gt;  
extern &quot;C&quot; {
</code></pre>

<p>The <code>extern &quot;C&quot;</code> block says that the enclosed functions should be stored in the library as C function calls and not as C++ function calls.<a href="#fn:3" id="fnref:3" title="see footnote" class="footnote">[3]</a> &#8220;DPI-C&#8221; expects C-style function names.</p>

<p>By convention we start all C routines with the &#8220;C_&#8221; prefix.</p>

<h4 id="initializingthemonitor">Initializing the Monitor</h4>

<p>The foo example is very simple in that it has only one agent and one agent package (<code>foo_pkg</code>). However you can imagine complex testbenches with many different kinds of agents and packages (<code>ahb_pkg</code> vs. <code>i2c_pkg</code>). In those cases different instances in the design must be able to point to different packages.</p>

<p>The <code>dpi_link::store_svScope()</code> function stores the current scope in an associative array using the <code>path</code> as a key. This allows the testbench to connect specific agent instances with specific package scopes.</p>

<pre><code>void C_initialize_monitor(const char * path){  
                dpi_link::store_svScope(path);  
        }
</code></pre>

<h4 id="callingstart_numbersinthedriverinstance">Calling <code>start_numbers()</code> in the Driver Instance</h4>

<p>This function uses the <code>path</code> argument to change the scope to the correct <code>foo_driver_bfm</code> and then calls the exported <code>start_numbers()</code> function in that module.</p>

<pre><code>void C_start_numbers(const char* path, unsigned int n){  
   svSetScope(svGetScopeFromName(path));  
   start_numbers(n);  
}
</code></pre>

<h4 id="callingsend_numberinthefoo_pkg">Calling <code>send_number()</code> in the <code>foo_pkg</code></h4>

<p>The <code>foo_monitor_bfm</code> module calls this function and passes it a number. Since the <code>foo_monitor_bfm</code> imports the function using the <code>context</code> keyword we know that we are currently in the monitor&#8217;s scope. We get the monitors path from the current scope using <code>svGetNameFromScope()</code> and <code>svGetScope()</code> and use that path to get the correct package scope from the dpi_link associative array. </p>

<p>Then we switch scope to the package (<code>foo_pkg</code> in this case) and call the <a href="#send_number"><br/>
<code>send_number()</code></a> function exported from <code>foo_pkg</code>.</p>

<pre><code>    void C_send_number(int unsigned n){  
            std::string path = svGetNameFromScope(svGetScope());  
            svScope pkg_scope = dpi_link::get_svScope(path.c_str());  
            svSetScope(pkg_scope);  
            send_number(path.c_str(), n);  
    }
}
</code></pre>

<p>Using <code>svSetScope()</code> along with the svScopes and path strings is the basis of all DPI communication.</p>

<h3 id="thedpiheader.hfile">The <code>dpiheader.h</code> File</h3>

<p>Your C source file must include the <code>dpiheader.h</code> file to get the proper declarations for your exported and imported functions. The <code>dpiheader.h</code> file is guaranteed to have the correct types in these declarations.</p>

<h2 id="ccommunicationsummary">C Communication Summary</h2>

<p>We create a thin C layer of functions that allows the HVL and XRTL to switch context and call functions exported from each other. Some things to remember:</p>

<ul>
<li>The XRTL and HVL export functions that can be accessed once you&#8217;ve set the proper svScope.</li>
<li>All imported communication functions must use the <code>context</code> keyword to ensure that the scope gets implicitly passed along with the function call.</li>
<li><code>svSetScope()</code> allows you to switch scope. You can get the scope that you pass to <code>svSetScope()</code> in a variety of ways.</li>
<li>Path strings store paths to specific instances of modules. You use <code>svGetScopeFromName()</code> and <code>svGetNameFromScope()</code> to move between svScope values and path string values.

<ul>
<li>All path strings are stored as C pointers, not as C++ strings.</li>
</ul></li>
</ul>

<h1 id="creatinganewpair">Creating a New HVL/XRTL Agent/BFM Pair.</h1>

<p>Agents need both HVL and XRTL sides to their implementation. On the HVL side you will provide <code>uvm_agents</code> that can be instantiated in a <code>uvm_env</code> class. On the XRTL side you will create modules that implement driver and monitor functionality. </p>

<p>Here are the steps to creating a new agent/bfm pair.</p>

<h2 id="onthexrtlside">On the XRTL Side</h2>

<p>Create a BFM module that will match with the agent on the HVL side. Make sure that this module instantiates a driver BFM and a monitor BFM. Remember to name these instances <code>&quot;driver&quot;</code> and <code>&quot;monitor&quot;</code>.</p>

<h3 id="awordaboutdatastructures">A Word about Data Structures</h3>

<p>In cases where you want to pass data back and forth using a complex data structure you should define that data structure in an XRTL package such as <code>foo_xrtl_pkg.sv</code>. This package must only contain synthesizable data types. </p>

<p>Since you cannot pass complex data structures through the TBX interface, you may want to use a union to convert a long array of bits too and from the complex structure. </p>

<h3 id="thedriverbfm">The Driver BFM</h3>

<p>The driver BFM must be written exclusively in XRTL and must be compilable in <code>tbxcomp</code>. </p>

<p>The BFM must export one or more functions that start operations. In cases where the function call passes data, synchronize the data transfer with the positive edge of the clock using an event. See the <a href="#foo_driver_bfm"><code>foo_driver_bfm</code></a> for an example.</p>

<p>In cases where the driver must notify the HVL that an operation is complete (such as the end of reset or the end of a read) include the <code>dpi_link_imports.svh</code> file and use the <code>trigger_hvl_event()</code> method to send the notification. The HVL must be written to wait for the notification.</p>

<h3 id="themonitorbfm">The Monitor BFM</h3>

<p>The monitor BFM watches the data traffic and sends data to the HVL. The BFM must import one or more functions that send data to the HVL. </p>

<p>Remember that the imported functions must use the <code>context</code> keyword to allow the C to receive the scope along with the data.</p>

<h2 id="onthehvlside">On the HVL Side</h2>

<p>Create an agent class that extends <code>dpi_link_agent</code>. This agent class should instantiate an <code>dpi_link_driver</code> and an <code>dpi_link_monitor</code>.</p>

<p>Import and export all communications functions at the top of the package that defines your agent, driver, and monitor classes. Functions cannot be exported or imported from within a class, though they can be used by the classes. Remember to use the <code>context</code> keyword when importing functions. </p>

<h3 id="dpi_link_proxyclasses"><code>dpi_link_proxy</code> Classes</h3>

<p>The <code>dpi_link_proxy</code> class provides core proxy functionality to its child classes. This functionality includes the following:</p>

<ul>
<li>A proxy object&#8217;s name is an XRTL path. The <code>dpi_link_proxy</code> checks that this path is valid.</li>
<li>All <code>dpi_link_proxy</code> objects are stored in the <code>dpi_link_proxy_pool</code> indexed by their names (module paths). The storing happens automatically when you use the static <code>get()</code> method to get .</li>
<li>The <code>dpi_link_proxy</code> provides a <code>get_xrtl_path()</code> method so you can access the XRTL path in children classes and if you have a handle to a proxy.</li>
<li>The <code>dpi_link_proxy</code> provides a <code>wait_for(int ret_val)</code> task that will block until the associated module calls <code>trigger_hvl_event()</code>. You can use this mechanism to wait for modules to complete their tasks.</li>
</ul>

<h4 id="thedriverproxy">The Driver Proxy</h4>

<p>The driver proxy extends <code>dpi_link_proxy</code>. It should provide methods that call the stimulus launching functions imported at the top of the package. These functions usually include a <code>path</code> argument that can be fulfilled with the proxy&#8217;s <code>get_xrtl_path()</code> method.</p>

<h4 id="themonitorproxy">The Monitor Proxy</h4>

<p>The monitor proxy extends <code>dpi_link_proxy</code>. These proxies usually contain a handle to the analysis port in the associated monitor. Monitoring functions in the package usually get a handle to these proxies using the <code>get()</code> method with the XRTL path as the index. The monitor proxy usually provides a <code>write()</code> function that writes data to the analysis port. </p>

<h2 id="theagentanddpi_link_agent">The Agent and <code>dpi_link_agent</code></h2>

<p>The <code>dpi_link_agent</code> class extends the typical <code>uvm_component</code> constructor by adding an <code>agent_path</code> argument. When you instantiate an <code>dpi_link_agent</code> it checks that the path points to a valid module instance. </p>

<p>You can access an <code>dpi_link_agent</code>&#8217;s path using the <code>get_xrtl_path()</code> method. </p>

<p>The agent instantiates the driver and monitor objects along with an appropriate <code>uvm_sequencer</code>. It passes the driver and sequencer it&#8217;s path using the <code>get_xrtl_path()</code> method. Using this method ensures that the path is correctly formatted for the DPI interface. </p>

<p>The agent also does the following:</p>

<ul>
<li>Instantiates the appropriate <code>uvm_sequencer</code>.</li>
<li>Connects the driver to the sequencer.</li>
<li>Exports the monitor&#8217;s analysis ports to the next level by creating analysis ports an connecting them to the monitor&#8217;s analysis ports.</li>
</ul>

<h3 id="thedriver">The Driver</h3>

<p>The driver is the grandchild class of <code>uvm_driver</code>. It has access to all the resources available to <code>uvm_driver</code> and uses the <code>seq_item_port</code> to get sequence items and commands from the testbench.</p>

<p>The driver creates an instance of the driver proxy. It uses the driver proxy to implement the commands stored in the sequence items it receives from the UVM sequencer. </p>

<pre><code>class foo_driver extends dpi_link_driver #(foo_item, foo_item);  
    `uvm_component_utils(foo_driver)

    function new(string name = &quot;&quot;, uvm_component parent = null, string agent_path = &quot;&quot;);  
        super.new(name, parent, agent_path);  
    endfunction

    foo_driver_proxy foo_driver_proxy_h;

    function void build_phase(uvm_phase phase);  
        foo_driver_proxy_h = foo_driver_proxy::get(get_xrtl_path());  
    endfunction

    task run_phase(uvm_phase phase);  
        foo_item foo_item_h;  
        forever begin  
            int dummy;  
            seq_item_port.get_next_item(foo_item_h);  
            foo_driver_proxy_h.start_numbers(foo_item_h.get_n());  
            foo_driver_proxy_h.wait_for(dummy);  
            seq_item_port.item_done();  
        end  
    endtask

endclass
</code></pre>

<h3 id="themonitor">The Monitor</h3>

<p>The monitor calls the <code>initialize_monitor()</code> function in its constructor and passes the XRTL path. This creates a module instance to package mapping in the C portion of the testbench. </p>

<p>The monitor also creates an analysis port and a monitor proxy. It stores the analysis port handle in the monitor proxy. That way the package-level monitoring function can find the proxy and write to the analysis port. </p>

<pre><code>class foo_monitor extends dpi_link_component;  
    `uvm_component_utils(foo_monitor)

    uvm_analysis_port #(foo_item) ap;

    `declare_set_get(foo_monitor_proxy, proxy)

    function new (string name = &quot;&quot;, uvm_component parent = null,  
        string xrtl_path = &quot;&quot;);  
        super.new(name, parent, xrtl_path);  
        foo_pkg::C_initialize_monitor(get_xrtl_path());  
    endfunction


    function void build_phase(uvm_phase phase);  
        foo_monitor_proxy proxy;  
        ap = new(&quot;ap&quot;, this);  
        proxy = foo_monitor_proxy::get(get_xrtl_path());  
        proxy.set_ap(ap);  
        set_proxy(proxy);  
    endfunction

endclass
</code></pre>

<h1 id="simulatingandrunningwithamakefile">Simulating and Running with a Makefile</h1>

<p>The Makefile below is a good starting point for your Makefile. It annotated inline: </p>

<pre><code>GPP=${QUESTA_HOME}/gcc-4.5.0-linux/bin/g++  
VSIM_OPTIONS=xrtl_top hvl_top -sv_lib sv_lib 
</code></pre>

<p>Point to the correct g++ compiler in the Questa library.<br/>
Notice that the <code>VSIM_OPTIONS</code> use the <code>-sv_lib</code> option to point to a library called <code>sv_lib.so</code> The <code>.so</code> gets appended automatically. </p>

<pre><code>sim: work/_info sv_lib.so  
    vsim ${VSIM_OPTIONS} -c -do &quot;run -all&quot;
</code></pre>

<p>This is the default target. It runs an interactive simulation. Notice that it uses <code>work/_info</code> as a predecessor. This keeps us from compiling unnecessarily when we run a simulation. </p>

<p>Notice that <code>sv_lib.so</code> is also a predecessor. This file must exist for us to simulate. </p>

<pre><code>gui: work/_info sv_lib.so  
    vsim ${VSIM_OPTIONS} -i -voptargs=&quot;+acc&quot; -do &quot;log -r /*&quot;
</code></pre>

<p>Same as above but with the GUI.</p>

<pre><code>work/_info: dpiheader.h 
</code></pre>

<p>The <code>work/_info</code> file is updated when we compile. This line forces us to create a new <code>dpiheader.h</code> file if one doesn&#8217;t exist. </p>

<pre><code>sv_lib.so: foo_tc.cpp dpi_link.o dpiheader.h  
    ${GPP} -I${BASE_DIR}/dpi_link  -I. -I${QUESTA_HOME}/include -fPIC foo_tc.cpp dpi_link.o -shared -o sv_lib.so 
</code></pre>

<p>Here is the compilation line for our DPI-C code. Notice that it leverages the <code>dpi_link.o</code> library and that it creates a <code>-shared</code> output with <code>-o sv_lib.so</code>. The <code>-fPIC</code> is necessary to create a shared library from <code>foo_tc.cpp</code>. </p>

<p>Also notice that we have to include the <code>${QUESTA_HOME}/include</code> directory and the <code>dpi_link</code> directory.</p>

<pre><code>dpiheader.h: *.sv *.svh tb.vf | work  
    vlog -f tb.vf -dpiheader dpiheader.h  
    touch dpiheader.h
</code></pre>

<p>Make the <code>dpiheader.h</code> file by compiling the design. This target depends upon all the <code>*.sv</code> and <code>*.svh</code> files as well as the <code>tb.vf</code> file. The <code>| work</code> dependency only fires if <code>work</code> doesn&#8217;t exist.</p>

<pre><code>work:  
    vlib work
</code></pre>

<p>If there is no <code>work</code> library then make one. </p>

<pre><code>dpi_link.o: dpi_link/*.cpp dpi_link/*.h  
    ${GPP} -I${BASE_DIR}/dpi_link  -I. -I${QUESTA_HOME}/include -fPIC ./dpi_link/dpi_link.cpp -shared -o dpi_link.o
</code></pre>

<p>Compile the <code>dpi_link.o</code> library if it doesn&#8217;t already exit. </p>

<pre><code>tb.vf : *.vinfo  
    make_filelist.py tb.vinfo
</code></pre>

<p>If any <code>*.vinfo</code> file has changed make a new <code>tb.vf</code> file.</p>

<pre><code>clean:  
    rm -rf work  
    rm -f *.vf transcript *.wlf *.log  
    rm -f *.so *.o dpiheader.h
</code></pre>

<p>Clean up. </p>

<p>This basic Makefile can be expanded to all projects. </p>

<div class="footnotes">
<hr />
<ol>

<li id="fn:1">
<p>The slashes in XRTL path names are deprecated. Future versions of the MCD DPI system will issue an error message. <a href="#fnref:1" title="return to article" class="reversefootnote">&#160;&#8617;</a></p>
</li>

<li id="fn:2">
<p>It&#8217;s fair to point out that we really shouldn&#8217;t be generating the clock in the BFM, but <em>c&#8217;est la vie</em>.) <a href="#fnref:2" title="return to article" class="reversefootnote">&#160;&#8617;</a></p>
</li>

<li id="fn:3">
<p>C++ function calls include information about the argument list that is not included in a C function call.  <a href="#fnref:3" title="return to article" class="reversefootnote">&#160;&#8617;</a></p>
</li>

</ol>
</div>

<!-- ##END MARKED WRAPPER## -->
    </div>
</body>
</html>
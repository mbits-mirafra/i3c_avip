/*****************************************************************************
 *
 * Copyright 2015 Mentor Graphics Corporation 
 * All Rights Reserved.
 *
 * THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION WHICH IS THE 
 * PROPERTY OF MENTOR GRAPHICS CORPORATION OR ITS LICENSORS AND IS SUBJECT 
 * TO LICENSE TERMS.
 *
 *****************************************************************************/

// Module: axi_master_hdl
//
// This module is the HDL-side master module for AXI. The user can connect
// an instance of it to an AXI bus to drive the bus for the master side.
// This module goes together with an HVL-side master module 'axi_master_hvl'.
// The two modules combined are a consolidation of 
// (1) the AXI QVIP interface and associated EZ-VIP master connectivity module
// (2) the AXI VTL interface and associated XRTL master module 
// into a unified pair of wrapper modules to provide a single common VIP 
// use model for simulation and emulation. 
//
// Input Parameters:
// ADDR_WIDTH      - Indicates address bus width.
// RDATA_WIDTH     - Indicates read data bus width.
// WDATA_WIDTH     - Indicates write data bus width.
// ID_WIDTH        - Indicates ID width.
// VIP_IF_UVM_NAME - Indicates interface name for which this module
//                   will be instantiated.
// VIP_IF_UVM_CTXT - Indicates interface context for which this module
//                   will be instantiated.

// (inline source)
module mgc_axi_master_hdl #(
   int ADDR_WIDTH  = 32,
   int RDATA_WIDTH = 32,
   int WDATA_WIDTH = 32,
   int ID_WIDTH    = 4,
   string VIP_IF_UVM_NAME,
   string VIP_IF_UVM_CONTEXT,
   int write_addr_channel_phase_emul_BUFFER_MAX_ELEMENTS = 17, 
   int write_channel_phase_BUFFER_MAX_ELEMENTS = 49, 
   int BURST_BUFFER = 16
)(mgc_axi_signal_if pin_if); //pragma attribute mgc_axi_master_hdl partition_module_xrtl

`ifdef XRTL

   //
   // Instantiate VTL XRTL BFM:
   //
   mgc_xrtl_axi_master #(
      .AXI_ADDRESS_WIDTH(ADDR_WIDTH),
      .AXI_RDATA_WIDTH(RDATA_WIDTH),
      .AXI_WDATA_WIDTH(WDATA_WIDTH),
      .AXI_ID_WIDTH(ID_WIDTH),
      .write_addr_channel_phase_emul_BUFFER_MAX_ELEMENTS(write_addr_channel_phase_emul_BUFFER_MAX_ELEMENTS),
      .write_channel_phase_BUFFER_MAX_ELEMENTS(write_channel_phase_BUFFER_MAX_ELEMENTS),
      .BURST_BUFFER(BURST_BUFFER)
   ) vip_mod (
      .ACLK(pin_if.ACLK),
      .ARESETn(pin_if.ARESETn),
      .AWVALID(pin_if.AWVALID),
      .AWADDR(pin_if.AWADDR),
      .AWLEN(pin_if.AWLEN),
      .AWSIZE(pin_if.AWSIZE),
      .AWBURST(pin_if.AWBURST),
      .AWLOCK(pin_if.AWLOCK),
      .AWCACHE(pin_if.AWCACHE),
      .AWPROT(pin_if.AWPROT),
      .AWID(pin_if.AWID),
      .AWREADY(pin_if.AWREADY),
      .AWUSER(pin_if.AWUSER),
      .ARVALID(pin_if.ARVALID),
      .ARADDR(pin_if.ARADDR),
      .ARLEN(pin_if.ARLEN),
      .ARSIZE(pin_if.ARSIZE),
      .ARBURST(pin_if.ARBURST),
      .ARLOCK(pin_if.ARLOCK),
      .ARCACHE(pin_if.ARCACHE),
      .ARPROT(pin_if.ARPROT),
      .ARID(pin_if.ARID),
      .ARREADY(pin_if.ARREADY),
      .ARUSER(pin_if.ARUSER),
      .RVALID(pin_if.RVALID),
      .RLAST(pin_if.RLAST),
      .RDATA(pin_if.RDATA),
      .RRESP(pin_if.RRESP),
      .RID(pin_if.RID),
      .RREADY(pin_if.RREADY),
      .RUSER(pin_if.RUSER),
      .WVALID(pin_if.WVALID),
      .WLAST(pin_if.WLAST),
      .WDATA(pin_if.WDATA),
      .WSTRB(pin_if.WSTRB),
      .WID(pin_if.WID),
      .WREADY(pin_if.WREADY),
      .WUSER(pin_if.WUSER),
      .BVALID(pin_if.BVALID),
      .BRESP(pin_if.BRESP),
      .BID(pin_if.BID),
      .BREADY(pin_if.BREADY),
      .BUSER(pin_if.BUSER)
   );

`else

   //
   // Instantiate the QVIP interface
   //
   typedef virtual mgc_axi #(
      .AXI_ADDRESS_WIDTH(ADDR_WIDTH), 
      .AXI_RDATA_WIDTH(RDATA_WIDTH),
      .AXI_WDATA_WIDTH(WDATA_WIDTH),
      .AXI_ID_WIDTH(ID_WIDTH)
   ) vip_if_t;
 
   mgc_axi #(
      .AXI_ADDRESS_WIDTH(ADDR_WIDTH), 
      .AXI_RDATA_WIDTH(RDATA_WIDTH),
      .AXI_WDATA_WIDTH(WDATA_WIDTH),
      .AXI_ID_WIDTH(ID_WIDTH)
   ) vip_if (pin_if.ACLK, pin_if.ARESETn);

   //
   // Put the interface into the UVM configuration structure, 
   //
   initial begin
     uvm_pkg::uvm_config_db #(vip_if_t)::set(null, VIP_IF_UVM_CONTEXT, VIP_IF_UVM_NAME, vip_if);

     vip_if.axi_set_master_abstraction_level(1'b0,1'b1); // Master end should be TLM    
   end

  // signals driven by slave
  assign vip_if.AWREADY = pin_if.AWREADY;
  assign vip_if.ARREADY = pin_if.ARREADY;
  assign vip_if.RVALID  = pin_if.RVALID;
  assign vip_if.RLAST   = pin_if.RLAST;
  assign vip_if.RDATA   = pin_if.RDATA;
  assign vip_if.RRESP   = pin_if.RRESP;
  assign vip_if.RID     = pin_if.RID;
  assign vip_if.WREADY  = pin_if.WREADY;
  assign vip_if.BVALID  = pin_if.BVALID;
  assign vip_if.BRESP   = pin_if.BRESP;
  assign vip_if.BID     = pin_if.BID;
  assign vip_if.RUSER   = pin_if.RUSER;
  assign vip_if.BUSER   = pin_if.BUSER;

  // signals driven by master
  assign pin_if.AWVALID  = vip_if.AWVALID;
  assign pin_if.AWADDR   = vip_if.AWADDR;
  assign pin_if.AWLEN    = vip_if.AWLEN;
  assign pin_if.AWSIZE   = vip_if.AWSIZE;
  assign pin_if.AWBURST  = vip_if.AWBURST;
  assign pin_if.AWLOCK   = vip_if.AWLOCK;
  assign pin_if.AWCACHE  = vip_if.AWCACHE;
  assign pin_if.AWPROT   = vip_if.AWPROT;
  assign pin_if.AWID     = vip_if.AWID;
  assign pin_if.ARVALID  = vip_if.ARVALID;
  assign pin_if.ARADDR   = vip_if.ARADDR;
  assign pin_if.ARLEN    = vip_if.ARLEN;
  assign pin_if.ARSIZE   = vip_if.ARSIZE;
  assign pin_if.ARBURST  = vip_if.ARBURST;
  assign pin_if.ARLOCK   = vip_if.ARLOCK;
  assign pin_if.ARCACHE  = vip_if.ARCACHE;
  assign pin_if.ARPROT   = vip_if.ARPROT;
  assign pin_if.ARID     = vip_if.ARID;
  assign pin_if.RREADY   = vip_if.RREADY;
  assign pin_if.WVALID   = vip_if.WVALID;
  assign pin_if.WLAST    = vip_if.WLAST;
  assign pin_if.WDATA    = vip_if.WDATA;
  assign pin_if.WSTRB    = vip_if.WSTRB;
  assign pin_if.WID      = vip_if.WID;
  assign pin_if.BREADY   = vip_if.BREADY;
  assign pin_if.WUSER    = vip_if.WUSER;
  assign pin_if.AWUSER   = vip_if.AWUSER;
  assign pin_if.ARUSER   = vip_if.ARUSER;

`endif

endmodule: mgc_axi_master_hdl
